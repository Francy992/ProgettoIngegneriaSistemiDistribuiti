TODO:
	Partire con scaricare il codice android sorgente.
	Provare a capirci qualcosa.
	Fare prova eliminando dal manifest la richiesta dei permessi e capire cosa succede.
	Iniziare la relazione, panoramica su Android (magari presa dalla tesi), su aspectj e programmazione ad aspetti, sui pattern authenticato e authorizator?
	Gestione del doppio utente in android e quindi far vedere che forse non serve. 
	Documentare i due esperimenti e far vedere il resto del codice se lo trovo.
	
	
	
	
	Implementazione di Context --> ContextImpl.java
	ContextImpl::checkPermission --> Sfrutta ActivityManagerNative.getDefault().checkPermission
		getDefault() restituisce l'istanza di un oggetto chiamato gDefault di tipo Singleton<IActivityManager> (nello specifico ActivityManagerProxy). 
		Quindi invoca il metodo della classe stessa checkPermission.
	ActivityManagerNative.getDefault().checkPermission --> Presumendo che asInterface restituisca un IActivityManager di tipo ActivityManagerService:
	
	
					public int checkPermission(String permission, int pid, int uid) {
						if (permission == null) {
							return PackageManager.PERMISSION_DENIED;
						}
						return checkComponentPermission(permission, pid, uid, -1, true);
					}
					
	checkComponentPermission --> return PackageManager.checkUidPermission(permission, uid). + vari casi
	PackageManager.checkUidPermission --> (si ipotizza che venga invocato il metodo del PackageManagerService) 
	
					public int checkUidPermission(String permName, int uid) {
						synchronized (mPackages) {
							Object obj = mSettings.getUserIdLPr(uid);
							if (obj != null) {
								GrantedPermissions gp = (GrantedPermissions)obj;
								if (gp.grantedPermissions.contains(permName)) {
									return PackageManager.PERMISSION_GRANTED;
								}
							} else {
								HashSet<String> perms = mSystemPermissions.get(uid);
								if (perms != null && perms.contains(permName)) {
									return PackageManager.PERMISSION_GRANTED;
								}
							}
						}
						return PackageManager.PERMISSION_DENIED;
					}
		
				in ordine il metodo fa: Prende i settings di questo utente, controlla che il permesso richiesto sia tra quelli già garantiti, restituisce permesso garantito o negato.
		
		
		
		Altro:
		MainActivity.requestPermissions --> activity.requestPermissions(permissions, requestCode);
		activity.requestPermissions(permissions, requestCode); --> startActivityForResult
		startActivityForResult --> Se tutto va bene invoca, dopo aver invocato l'activity e gestito la risposta il comando passa a:  mMainThread.sendActivityResult
		mMainThread.sendActivityResult --> Viene attivata una ClientTransaction dopo averla fatta schedulare ad un thread.  mAppThread.scheduleTransaction(clientTransaction)
		mAppThread.scheduleTransaction(clientTransaction) --> ActivityThread.this.scheduleTransaction(transaction)
		ActivityThread.this.scheduleTransaction(transaction --> sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);
		sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction); -->  mH.sendMessage(msg) (quello di ActivityThread che implementa i metodi astratti di ClientTransactionHandler.
		 mH.sendMessage(msg); --> sendMessageDelayed(msg, 0);
		 sendMessageDelayed(msg, 0); --> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
		 sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis) --> enqueueMessage(queue, msg, uptimeMillis);
		 enqueueMessage(queue, msg, uptimeMillis); --> queue.enqueueMessage(msg, uptimeMillis); --> qui ci blocchiamo e con ogni probabilità ripartirà da 
			public abstract void handleSendResult(IBinder token, List<ResultInfo> results, String reason) di ActivityThread in quanto estende ClientTransactionHandler ed è 
			definito come:/** Deliver result from another activity. */
		handleSendResult(IBinder token, List<ResultInfo> results, String reason) --> deliverResults(r, results, reason);
		deliverResults(r, results, reason) --> r.activity.dispatchActivityResult(ri.mResultWho, ri.mRequestCode, ri.mResultCode, ri.mData, reason)
		r.activity.dispatchActivityResult(ri.mResultWho, ri.mRequestCode, ri.mResultCode, ri.mData, reason) --> onRequestPermissionsResult(requestCode, permissions, grantResults)
		onRequestPermissionsResult(requestCode, permissions, grantResults) --> Questa è la callBack, qui viene invocato il codice scritto da noi.
		
		
		
		
		Ultima prova - No manifest:
		Attenzionare @Override
		public void startActivityForResult( 
			mInstrumentation.execStartActivity in Activity 
		mInstrumentation.execStartActivity --> (Si da per scontato che a partire sia MonitoringInstrumentation.execStartActivity)...
													Se va bene lui esegue startActivity e controlla che non ci siano errori con checKqualcosa, poi ritorna null.
		Con il ritorno di null cancella l'input dell'utente tanto ormai lo startActivity precedente si è avviato.


		StartActivity avvia Instrumental.execStartActivityFromAppTask che dovrebbe invocare appTask.startActivity
		appTask.startActivity di AppTaskImpl --> mService.getActivityStartController().obtainStarter
		mService.getActivityStartController().obtainStarter --> Ritorna un oggetto di tipo ActivityStarter che una volta configurato come si deve va in esecuzione
		ActivityStarter.execute() --> ActivityStarter.startActivity
		ActivityStarter.startActivity --> ActivityStarter.startActivity
		ActivityStarter.startActivity --> err = ActivityManager.START_PERMISSION_DENIED. Da qui torna indietro.


	